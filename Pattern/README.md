# 테스트 주도 개발 패턴

기본적인 전략에 관한 질문에 답해야한다.
- 테스트 한다는 것은 무엇을 뜻하는가?
- 테스트를 언제 해야할 것인가?
- 테스트할 로직을 어떻게 고를 것인가?
- 테스트할 데이터를 어떻게 고를 것인가?

## 격리된 테스트

- 테스트는 충분히 빨라서 **직접, 자주 실행**할 수 있게 만들자
- 앞 부분에서 실패한 테스트가 다음 테스트에 영향을 끼치지 않아야 한다
  - 테스트 **실행 순서에 독립적**이여야 한다.
  - 결과적으로 시스템이 **_응집도는 높고 결합도는 낮은 객체의 모음_** 으로 구성되도록 유도한다.

## 테스트 목록

- 구현해야 할 필요가 있는 모든 오퍼레이션의 사용 예를 적는다.
- 존재하지 안흔 오퍼레이션에 대해서는 해당 오퍼레이션의 널버전을 리스트에 적는다.
- 작업을 끝내기 전 반드시 해야할 리팩토링 목록을 적는다.

> 테스트를 한번에 다 만들지 않는 이유
>- 한번에 만든 테스트는 리팩토링에 대해서 관성을 가지는 경우가 생김
>  - 모든 테스트들에 대해 리팩토링을 일일히 해주는 귀찮은 상황이 생기면 안하는 경우가 생길 수 있다.
>- 열 개의 테스트가 전부 실패한다면 모든 테스트를 성공시키는데 오랜 시간이 걸릴 수 있다.
>  - 즉, 오랫동안 실패한 상태로 두는 것보단 단계적이고 빠른 속도로 성공을 확인하는 것이 적절하다.

## 단언 우선(Assertion)

단언을 제일 먼저 쓰고 시작하자
- 시스템의 경우, 완료된 시스템이 어떤 결과를 낼거라는 걸 정하고 시작하는 것이다.
- 메소드의 경우, 기능이 완료되면 통과할 수 있는 테스트 부터 작성하자.
- 테스트를 경우, 테스트가 완료되었을 때, 통과해야 되는 **_assertion_** 부터 작성한다.

## 테스트 데이터
- 테스트를 읽을 때 쉽고 따라가기 좋을 만한 데이터를 사용하자.
- 테스트 데이터를 사용할 때, 동일한 상수 쓰지말자
<br/> ex) 1+1, 2+2는 상관없지만, 인자의 순서가 뒤집히는 경우를 상정.
- 실제 데이터는 다음 경우에 사용
  - 실제 실행을 통해 수집한 결과를 이용해 실시간 시스템을 테스트 하는 경우.
  - 예전 시스템의 출력과 현재 시스템의 출력을 비교하는 경우(병렬 테스팅).
  - 리팩토링 한 후와 기존 결과가 동일한지 확인.

---

# 테스팅 패턴

## 자식 테스트

큰 테스트 케이스를 작성할 시
- 큰 테스트 케이스에서 실패하는 작은 테스트 케이스를 작성.
- 작은 테스트 케이스가 실행되도록 코드 작성.
- 이 후 큰 테스트 케이스를 추가

## 모의 객체

비용이 많이 들거나 복잡한 리소스에 의존하는 객체 테스트 시
- 상수를 반환하게 하는 속임수 객체를 생성
- 복잡한 객체 실행의 자원을 아끼고 결과에 대한 견고함을 얻을 수 있음
- 가독성이 증진되며, 설계의 커플링이 감소

## 셀프 션트(self shunt)

어떤 객체가 다른 객체와 제대로 메세지를 주고 받는지 확인할 때
- 객체가 원래의 대상이 아닌, 테스트 케이스와 연결
- 테스트 케이스가 구현할 인터페이스르를 위한 인터페이스 추출이 필요

## 크래시 테스트 더미

호출되지 않을 것 같은 에러코드 테스트
- 실제 작업을 수행하는 것이 아닌 예외만을 발생시키는 특수 객체 생성
- 수 많은 에러 상황에서는 작동하길 원하는 부분에 대해서만 진행
- Java의 익명 내부 클래스(Anonymous inner class)를 이용하면 원하는 대상 메소드에 편리하게 오류를 발생 시킬 수 있음

---

# 빨간 막대 패턴

- 테스트를 언제 어디에 작성할 것인가?
- 테스트 작성을 언제 멈출지? 에 대한 패턴.

## 한 단계 테스트

다음 테스트를 고를 때 무엇을 기준으로 할 것인가? <br/>
&gt; **새로운 무언가**를 가르쳐 주며, **구현할 수 있다는 확신**이 드는 테스트를 고를 것.

상향식, 하향식 둘다 TDD의 프로세스를 효과적으로 설명할 수 없다. <br/>
&gt; 이러한 수직적 메타포는 프로그램이 시간에 따라 어떻게 변해 가는지에 대한 단순화 시각화 일 뿐.

따라서, 우리는 ***아는 것에서 모르는 것으로*** 방향성을 가져야 한다.

## 시작 테스트

어떤 테스트를 먼저 시작하는게 좋을까? <br/>
&gt; 오퍼레이션이 **아무 일도 하지 않는 경우**를 먼저 테스트하자!

시작으로 현실적인 테스트를 하나 작성한다면 아래 문제에 대한 해결책을 찾을 수 있다.
- 이 오퍼레이션을 어디에 두어야하나?
- 적절한 입력 값은 무엇인가?
- 입력에 대한 적절한 출력이 무엇인가?

우리는 테스트, 실행, 리팩토링의 순환을 간결하고 신속하게 가져가야하므로, **쉬운 입력과 출력**을 사용해 각 
단계의 간격을 줄일 수 있다.

```java
Socket socket = new Socket();
String msg = "hello";
socket.write(msg);
AssertEquals(msg, socket.read);
```

## 설명 테스트

자동화된 테스트를 널리쓰이게 하고싶다면? <br/>
&gt; 테스트를 통해 설명을 요청하고 테스트를 통해 설명하라!

## 학습 테스트

외부에서 만든 소프트웨어에 대한 테스트를 작성해야할 때는 어떨까?
- 바로 사용하는 대신 API가 우리 예상대로 실행된다는 것을 확인할 만한 테스트를 만들자
- 우리가 제대로 이해했다면 간단한 테스트가 통과될 것이며 우리는 그 API를 사용하면 된다.
- 또한 패키지의 새로운 버젼이 업데이트 된다면, 기존 API 테스트가 통과되는지 확인해 언제나 어플리케이션에 제대로 동작함을 보장할 수 있다.

## 회귀 테스트

시스템 장애가 보고될 경우에 우리가 해야할 일은
1. 장애로 인해 실패하는 테스트를 작성
2. 통과할 경우엔 장애가 수정되었다고 볼 수 있는 테스트를 작성

---

# 초록 막대 패턴

- 코드가 테스트를 통과하게 만들기 위해 사용하는 패턴
- 비록 코드에 악취가 가득할지라도

## 가짜로 구현하기

실패하는 테스트를 만든 후 첫 번째 구현은 ***상수***를 반환하게 하자!
- 일단 테스트가 통과하면 단계적으로 상수를 변수로 사용하는 수식으로 변형.
- 무언가 돌아가는건 그렇지 않은 것보단 무조건 좋다
- 코드 구조가 완성되지 않았지만, 일단 도달하면 동작하는 것을 보장하기 때문이다.
```java
return "0 run, 0 failed";
return String.format("0 run, %d failed", failCount);
return String.format(%d run, %d failed", runCount, failCount);
```

## 삼각측량
추상화 과정을 테스트할 때 보수적으로 할 수 있는 방법은, **예시가 두개 이상일 때만 추상화**하는 것이다.
- 삼각측량의 장점은 규칙이 명확하다는 것이다.
- 두개의 assertion이 있고 하나의 함수에 대해 올바른 추상화가 된다면, 반드시 하나를 삭제할 수 있다.]
```java
public void testSum(){
    assertEquals(4, plus(3, 1));
}
public int plus(int augend, int addend){
    return 4;
}
```
```java
public void testSum(){
    assertEquals(4, plus(3, 1));
    assertEquals(7, plus(4, 3));
}
public int plus(int augend, int addend){
    return augend + addend;
}
```

## 명백한 구현

단순한 연산은 그냥 구현해 버려라.
- 사실 plus와 같은 단순한 구현은 굳이 가짜로 구현하기나 삼각측량이 필요없을 수 있다.
- 그렇기에 그냥 명백한 구현을 통해 구현을 하는 것으로 작업을 진행한다.
- 하지만 **제대로 동작하는**, **깨끗한 코드**는 한번에 이루기 어려울 수 있으며,
명백한 구현은 제대로 동작하지 않는 주기에 빠질 수 있음을 명심하자.
- 그럴때는 다시 제대로 동작하는 코드를 만들고 깨끗한 코드를 만드는 작업 순서로 진행하자.

## 하나에서 여럿으로

객체 컬렉션(Collection)을 다루는 연산에서는 **일단 컬렉션 없이 구현** 후 컬렉션을 사용하자.
- 테스트 케이스에 인자를 추가 또는 변경하며 테스트 케이스에 영향을 주지 않으면서 자유로이 구현을 변경 할 수 있다.
```java
public void testSum(){
    assertEquals(5, sum(5));    
}
public void sum(int value){
    return value;    
}
```
```java
public void testSum(){
    assertEquals(5, sum(5));    
}
public void sum(int[] values){
    return value;    
}
```
```java
public void testSum(){
        assertEquals(5, sum(5));
}
public void sum(int[] values){
        int sum = 0 ;
        for(int i = 0 ; i < values.length(), ++i){
            sum += values[i];
        }
        return sum;
}
```
```java
public void testSum(){
        //assertEquals(5, sum(5));
        assertEquals(12, sum(new int[](5, 7)));
}
public void sum(int[] values){
        int sum = 0 ;
        for(int i = 0 ; i < values.length(), ++i){
            sum += values[i];
        }
        return sum;
}
```