# 테스트 주도 개발 패턴

## 격리된 테스트

- 테스트는 충분히 빨라서 **직접, 자주 실행**할 수 있게 만들자
- 앞 부분에서 실패한 테스트가 다음 테스트에 영향을 끼치지 않아야 한다
  - 테스트 **실행 순서에 독립적**이여야 한다.
  - 결과적으로 시스템이 **_응집도는 높고 결합도는 낮은 객체의 모음_** 으로 구성되도록 유도한다.

## 테스트 목록

- 구현해야 할 필요가 있는 모든 오퍼레이션의 사용 예를 적는다.
- 존재하지 안흔 오퍼레이션에 대해서는 해당 오퍼레이션의 널버전을 리스트에 적는다.
- 작업을 끝내기 전 반드시 해야할 리팩토링 목록을 적는다.

> 테스트를 한번에 다 만들지 않는 이유
>- 한번에 만든 테스트는 리팩토링에 대해서 관성을 가지는 경우가 생김
>  - 모든 테스트들에 대해 리팩토링을 일일히 해주는 귀찮은 상황이 생기면 안하는 경우가 생길 수 있다.
>- 열 개의 테스트가 전부 실패한다면 모든 테스트를 성공시키는데 오랜 시간이 걸릴 수 있다.
>  - 즉, 오랫동안 실패한 상태로 두는 것보단 단계적이고 빠른 속도로 성공을 확인하는 것이 적절하다.

## 단언 우선(Assertion)

단언을 제일 먼저 쓰고 시작하자
- 시스템의 경우, 완료된 시스템이 어떤 결과를 낼거라는 걸 정하고 시작하는 것이다.
- 메소드의 경우, 기능이 완료되면 통과할 수 있는 테스트 부터 작성하자.
- 테스트를 경우, 테스트가 완료되었을 때, 통과해야 되는 **_assertion_** 부터 작성한다.

## 테스트 데이터
- 테스트를 읽을 때 쉽고 따라가기 좋을 만한 데이터를 사용하자.
- 테스트 데이터를 사용할 때, 동일한 상수 쓰지말자
<br/> ex) 1+1, 2+2는 상관없지만, 인자의 순서가 뒤집히는 경우를 상정.
- 실제 데이터는 다음 경우에 사용
  - 실제 실행을 통해 수집한 결과를 이용해 실시간 시스템을 테스트 하는 경우.
  - 예전 시스템의 출력과 현재 시스템의 출력을 비교하는 경우(병렬 테스팅).
  - 리팩토링 한 후와 기존 결과가 동일한지 확인.

# 테스팅 패턴

## 자식 테스트

큰 테스트 케이스를 작성할 시
- 큰 테스트 케이스에서 실패하는 작은 테스트 케이스를 작성.
- 작은 테스트 케이스가 실행되도록 코드 작성.
- 이 후 큰 테스트 케이스를 추가

## 모의 객체

비용이 많이 들거나 복잡한 리소스에 의존하는 객체 테스트 시
- 상수를 반환하게 하는 속임수 객체를 생성
- 복잡한 객체 실행의 자원을 아끼고 결과에 대한 견고함을 얻을 수 있음
- 가독성이 증진되며, 설계의 커플링이 감소

## 셀프 션트(self shunt)

어떤 객체가 다른 객체와 제대로 메세지를 주고 받는지 확인할 때
- 객체가 원래의 대상이 아닌, 테스트 케이스와 연결
- 테스트 케이스가 구현할 인터페이스르를 위한 인터페이스 추출이 필요

## 크래시 테스트 더미

호출되지 않을 것 같은 에러코드 테스트
- 실제 작업을 수행하는 것이 아닌 예외만을 발생시키는 특수 객체 생성
- 수 많은 에러 상황에서는 작동하길 원하는 부분에 대해서만 진행
- Java의 익명 내부 클래스(Anonymous inner class)를 이용하면 원하는 대상 메소드에 편리하게 오류를 발생 시킬 수 있음